import React, { useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import { Modal, Form, Button, ListGroup, Alert, Tab, Tabs, Badge } from 'react-bootstrap';
import { fetchStaffList, getConversationsForForwarding, forwardMessage } from '../services/staffChatApi';

/**
 * ShareMessageModal Component
 * Modal for forwarding messages to existing conversations or new people
 * 
 * NEW FORWARDING APPROACH:
 * - Shows user's existing conversations for quick selection
 * - Allows selecting new people to create new conversations automatically
 * - Uses backend forward endpoint that handles both existing and new conversations
 * - Backend preserves message content but NOT reply chains (reply_to = null)
 * - Real-time updates sent via Pusher to all participants automatically
 * - FCM notifications sent to recipients (except sender)
 * 
 * @see Backend: /api/staff-chat/<hotel_slug>/messages/<message_id>/forward/
 * @see Backend: /api/staff-chat/<hotel_slug>/conversations/for-forwarding/
 */
const ShareMessageModal = ({
  show,
  onHide,
  message,
  hotelSlug,
  currentUserId,
  onMessageForwarded, // Callback when message is successfully forwarded
  onOpenConversation, // Callback to open the conversation where message was forwarded
}) => {
  // Tab management
  const [activeTab, setActiveTab] = useState('conversations');
  
  // Conversations state
  const [conversations, setConversations] = useState([]);
  const [selectedConversations, setSelectedConversations] = useState([]);
  const [conversationSearch, setConversationSearch] = useState('');
  const [loadingConversations, setLoadingConversations] = useState(false);
  
  // New people state
  const [staffList, setStaffList] = useState([]);
  const [selectedNewPeople, setSelectedNewPeople] = useState([]);
  const [staffSearch, setStaffSearch] = useState('');
  const [loadingStaff, setLoadingStaff] = useState(false);
  
  // Shared state
  const [forwarding, setForwarding] = useState(false);
  const [error, setError] = useState(null);
  const [showSuccess, setShowSuccess] = useState(false);
  const [forwardResults, setForwardResults] = useState(null);

  // Load data when modal opens
  useEffect(() => {
    if (show) {
      loadConversations();
      setSelectedConversations([]);
      setSelectedNewPeople([]);
      setConversationSearch('');
      setStaffSearch('');
      setError(null);
    }
  }, [show]);

  // Load conversations with search
  useEffect(() => {
    if (show && activeTab === 'conversations') {
      const timer = setTimeout(() => {
        loadConversations(conversationSearch);
      }, 300);
      return () => clearTimeout(timer);
    }
  }, [conversationSearch, show, activeTab]);

  // Load staff when switching to new people tab
  useEffect(() => {
    if (show && activeTab === 'newPeople' && staffList.length === 0) {
      loadStaff();
    }
  }, [show, activeTab]);

  // Load staff with search
  useEffect(() => {
    if (show && activeTab === 'newPeople' && staffList.length > 0) {
      const timer = setTimeout(() => {
        loadStaff(staffSearch);
      }, 300);
      return () => clearTimeout(timer);
    }
  }, [staffSearch, show, activeTab]);

  /**
   * Load staff list with pagination support
   * @param {string} url - Pagination URL or null for first page
   * @param {string} search - Search query
   */
  const loadStaff = async (url = null, search = '') => {
    const isLoadingMore = !!url;
    
    if (isLoadingMore) {
      if (loadingMore) return; // Prevent multiple simultaneous loads
      setLoadingMore(true);
    } else {
      setLoading(true);
    }
    
    setError(null);
    
    try {
      console.log('ðŸ”„ Loading staff list:', { url, search, isLoadingMore });
      
      let data;
      if (url) {
        // Load from pagination URL
        // Get token from user data in localStorage
        const storedUser = localStorage.getItem('user');
        const userData = storedUser ? JSON.parse(storedUser) : null;
        const token = userData?.token || null;
        
        if (!token) {
          throw new Error('No authentication token found');
        }
        
        const response = await fetch(url, {
          headers: {
            'Authorization': `Token ${token}`, // Use 'Token' not 'Bearer'
            'Content-Type': 'application/json',
            'X-Hotel-ID': userData?.hotel_id?.toString() || '',
            'X-Hotel-Slug': userData?.hotel_slug || hotelSlug
          }
        });
        if (!response.ok) {
          throw new Error(`Failed to load staff: ${response.status} ${response.statusText}`);
        }
        data = await response.json();
      } else {
        // Load first page with optional search
        data = await fetchStaffList(hotelSlug, search, '', 50); // 50 per page
      }
      
      console.log('ðŸ“‹ Fetched staff data:', {
        count: data?.count || data?.length || 0,
        hasNext: !!data?.next,
        currentUserId
      });
      
      // Handle both paginated and non-paginated responses
      const results = data?.results || data || [];
      
      // Filter out current user
      const otherStaff = results.filter(
        staff => staff.id !== currentUserId && staff.is_active !== false
      );
      
      console.log('âœ… Filtered staff:', {
        filteredCount: otherStaff.length,
        isLoadingMore
      });
      
      // Append or replace staff list
      setStaffList(prev => isLoadingMore ? [...prev, ...otherStaff] : otherStaff);
      setNextPage(data?.next || null);
      setHasMore(!!data?.next);
      
    } catch (err) {
      console.error('âŒ Error loading staff list:', err);
      setError('Failed to load staff members');
    } finally {
      if (isLoadingMore) {
        setLoadingMore(false);
      } else {
        setLoading(false);
      }
    }
  };

  /**
   * Prefetch all conversations when modal opens
   * This allows instant duplicate checking without API calls during share
   */
  const prefetchConversations = async () => {
    setLoadingConversations(true);
    try {
      console.log('ðŸ”„ Prefetching all conversations...');
      const response = await fetchConversations(hotelSlug);
      const conversations = response?.results || response || [];
      console.log('âœ… Prefetched conversations:', {
        count: conversations.length,
        conversationIds: conversations.map(c => c.id)
      });
      setAllConversations(conversations);
    } catch (err) {
      console.error('âŒ Error prefetching conversations:', err);
      setAllConversations([]); // Set empty array on error
    } finally {
      setLoadingConversations(false);
    }
  };

  // Scroll handler for infinite scroll
  const handleScroll = (e) => {
    const { scrollTop, scrollHeight, clientHeight } = e.target;
    
    // Trigger load when scrolled within 100px of bottom
    if (scrollHeight - scrollTop <= clientHeight + 100) {
      if (hasMore && !loadingMore && nextPage) {
        setLoadingMore(true);
        loadStaff(nextPage);
      }
    }
  };

  const toggleStaff = (staffId) => {
    console.log('ðŸ”„ Toggling staff selection:', {
      staffId,
      currentSelection: selectedStaff,
      action: selectedStaff.includes(staffId) ? 'REMOVE' : 'ADD'
    });
    
    setSelectedStaff(prev => {
      const newSelection = prev.includes(staffId)
        ? prev.filter(id => id !== staffId)
        : [...prev, staffId];
      
      console.log('âœ… New staff selection:', newSelection);
      return newSelection;
    });
  };

  /**
   * Find existing conversation with the selected staff members
   * Uses prefetched conversations for instant duplicate checking
   * Checks for exact participant match (order-independent)
   */
  const findExistingConversation = (selectedStaffIds) => {
    console.log('ðŸ” Searching for existing conversation with staff IDs:', selectedStaffIds);
    
    // Use prefetched conversations (no API call needed!)
    console.log('ï¿½ Checking prefetched conversations:', {
      count: allConversations.length,
      conversationIds: allConversations.map(c => c.id)
    });
    
    // Create a Set with current user and selected staff for comparison
    const targetParticipants = new Set([currentUserId, ...selectedStaffIds]);
    console.log('ðŸ” Target participant set:', Array.from(targetParticipants));
    
    // Find matching conversation
    const existingConv = allConversations.find(conv => {
      if (!conv.participants || conv.participants.length === 0) {
        return false;
      }
      
      // Create Set of participant IDs from this conversation
      const convParticipants = new Set(conv.participants.map(p => p.id));
      
      // Check if both sets have same size and same members
      if (convParticipants.size !== targetParticipants.size) {
        return false;
      }
      
      // Check if all target participants are in this conversation
      const isMatch = Array.from(targetParticipants).every(id => convParticipants.has(id));
      
      if (isMatch) {
        console.log('âœ… Found existing conversation (from prefetch):', {
          id: conv.id,
          participants: conv.participants.map(p => ({ id: p.id, name: p.full_name }))
        });
      }
      
      return isMatch;
    });
    
    if (!existingConv) {
      console.log('ðŸ†• No existing conversation found - will create new one');
    }
    
    return existingConv;
  };

  const handleShare = async () => {
    console.log('ðŸ“¤ SHARE INITIATED');
    console.log('ðŸ“¤ Current state:', {
      selectedStaff,
      selectedStaffCount: selectedStaff.length,
      currentUserId,
      hotelSlug,
      messageId: message.id
    });

    if (selectedStaff.length === 0) {
      console.warn('âš ï¸ No staff selected');
      setError('Please select at least one staff member');
      return;
    }

    // Get details of selected staff
    const selectedStaffDetails = staffList.filter(staff => selectedStaff.includes(staff.id));
    console.log('ðŸ‘¥ Selected staff members:', selectedStaffDetails.map(s => ({
      id: s.id,
      name: s.full_name || `${s.first_name} ${s.last_name}`,
      role: typeof s.role === 'string' ? s.role : s.role?.name
    })));

    setSharing(true);
    setError(null);

    try {
      console.log('ðŸ“¤ Sharing message to staff:', {
        originalMessageId: message.id,
        originalSender: message.sender?.first_name,
        selectedStaffIds: selectedStaff,
        selectedStaffNames: selectedStaffDetails.map(s => s.full_name || `${s.first_name} ${s.last_name}`),
        hasAttachments: message.attachments?.length > 0,
        currentUserId,
        hotelSlug
      });

      // Step 1: Check for existing conversation FIRST (prevents duplicates)
      // Uses prefetched conversations - instant, no API call needed!
      console.log('ðŸ”„ Step 1: Checking prefetched conversations for duplicates...');
      let conversation = findExistingConversation(selectedStaff);
      
      if (conversation) {
        console.log('âœ… Found existing conversation - will reuse it!', {
          conversationId: conversation.id,
          participants: conversation.participants?.map(p => ({ id: p.id, name: p.full_name }))
        });
        console.log('ðŸŽ¯ NO DUPLICATE - Using existing conversation (from prefetch)');
      } else {
        // Step 2: Create new conversation via API (only if doesn't exist)
        console.log('ðŸ†• No existing conversation found - creating new one');
        console.log('ðŸ“‹ Request payload:', {
          hotelSlug,
          participant_ids: selectedStaff,
          endpoint: `/staff_chat/${hotelSlug}/conversations/`
        });
        
        conversation = await createConversation(hotelSlug, selectedStaff);
        
        console.log('âœ… Got/created conversation from backend:', {
          conversationId: conversation.id,
          conversationTitle: conversation.title,
          wasCreated: conversation._wasCreated,
          wasExisting: conversation._wasExisting,
          statusMessage: conversation._wasCreated 
            ? 'ðŸ†• Backend CREATED new conversation'
            : conversation._wasExisting
              ? 'âœ… Backend RETURNED existing conversation'
              : 'â“ Status unclear',
          created_at: conversation.created_at,
          updated_at: conversation.updated_at,
          participants: conversation.participants?.map(p => ({
            id: p.id,
            name: p.full_name || p.first_name
          }))
        });
        
        // Log backend behavior
        if (conversation._wasCreated) {
          console.log('ðŸ†• Backend created a NEW conversation (status 201)');
          console.log('ðŸ’¡ This should only happen when no matching conversation exists');
          
          // Add new conversation to prefetched list for next forward in same session
          setAllConversations(prev => [...prev, conversation]);
        } else if (conversation._wasExisting) {
          console.log('âœ… Backend returned an EXISTING conversation (status 200) - no duplicates!');
          
          // Add to prefetched list if not already there
          setAllConversations(prev => {
            const exists = prev.some(c => c.id === conversation.id);
            return exists ? prev : [...prev, conversation];
          });
        }
      }

      // Step 3: Build shared message - handle images differently
      let sharedText = message.message || message.content || '';
      
      // Skip "[File shared]" placeholder text
      if (sharedText === '[File shared]') {
        sharedText = '';
      }
      
      // Build forwarded message with clear prefix
      let finalText = '';
      
      // Check if message is already a forwarded message (to prevent double "Forwarded")
      const isAlreadyForwarded = sharedText.trim().startsWith('ðŸ“¤ Forwarded');
      
      if (!isAlreadyForwarded) {
        // Add "Forwarded" label at the top only if not already forwarded
        finalText = 'ðŸ“¤ Forwarded';
      }
      
      // Add additional text if provided by user
      if (additionalText.trim()) {
        finalText += finalText ? `\n\n${additionalText.trim()}` : additionalText.trim();
      }
      
      // Add original message text if it exists and isn't empty
      if (sharedText && sharedText.trim()) {
        finalText += finalText ? `\n\n${sharedText}` : sharedText;
      }
      
      // Use the final constructed text
      sharedText = finalText;

      // Step 4: Send the shared message with attachments if present
      console.log('ðŸ”„ Step 4: Sending shared message to conversation', conversation.id);
      
      let result;
      
      // If message has attachments, we need to download and re-upload them
      if (message.attachments && message.attachments.length > 0) {
        console.log('ðŸ“Ž Message has attachments, preparing to share files:', {
          attachmentCount: message.attachments.length,
          attachments: message.attachments.map(att => ({
            id: att.id,
            fileName: att.file_name,
            fileType: att.file_type,
            fileUrl: att.file_url
          }))
        });
        
        try {
          // Download files from URLs and convert to File objects
          // Note: Don't use credentials: 'include' - Cloudinary doesn't allow it with CORS
          const filePromises = message.attachments.map(async (att) => {
            console.log('ðŸ“¥ Downloading file:', att.file_url);
            const response = await fetch(att.file_url, {
              mode: 'cors'
              // No credentials - public Cloudinary URLs
            });
            
            if (!response.ok) {
              throw new Error(`Failed to download ${att.file_name}: ${response.status}`);
            }
            
            const blob = await response.blob();
            console.log('âœ… Downloaded:', att.file_name, 'Size:', blob.size, 'Type:', blob.type);
            
            return new File([blob], att.file_name, { type: blob.type || 'application/octet-stream' });
          });
          
          const files = await Promise.all(filePromises);
          console.log('âœ… All files downloaded and ready to upload:', files.map(f => ({
            name: f.name,
            size: f.size,
            type: f.type
          })));
          
          // Upload files with the message text
          result = await uploadFiles(hotelSlug, conversation.id, files, sharedText || null);
          console.log('âœ… Files shared successfully with message');
          
        } catch (fileError) {
          console.error('âŒ Error downloading/uploading files:', fileError);
          console.error('âŒ Error details:', {
            message: fileError.message,
            stack: fileError.stack
          });
          
          // Fallback to text-only share with attachment URLs
          let fallbackText = sharedText || '';
          if (message.attachments.length > 0) {
            if (fallbackText) fallbackText += '\n\n';
            fallbackText += `ðŸ“Ž Shared ${message.attachments.length} file(s):\n`;
            message.attachments.forEach(att => {
              // Include clickable link to the file
              fallbackText += `\n${att.file_name}: ${att.file_url}`;
            });
          }
          result = await sendMessage(hotelSlug, conversation.id, fallbackText);
          console.log('âš ï¸ Shared as text with file URLs (file upload failed)');
        }
      } else {
        // No attachments, just send text
        console.log('ðŸ“ Message content (text only):', sharedText);
        result = await sendMessage(hotelSlug, conversation.id, sharedText);
      }
      
      console.log('âœ… Message forwarded successfully!');
      console.log('ðŸ“Š Forward details:', {
        newMessageId: result?.id,
        targetConversationId: conversation.id,
        selectedStaffIds: selectedStaff,
        selectedStaffCount: selectedStaff.length,
        currentUserId,
        conversationParticipants: conversation.participants?.map(p => p.id)
      });
      console.log('â„¹ï¸ Real-time update will be sent via Pusher to all participants in conversation', conversation.id);
      
      // Verify the conversation was created with correct participants
      if (conversation.participants) {
        const participantIds = conversation.participants.map(p => p.id);
        console.log('ðŸ” Verification - Participant IDs in conversation:', participantIds);
        console.log('ðŸ” Verification - Does conversation include current user?', participantIds.includes(currentUserId));
        console.log('ðŸ” Verification - Does conversation include selected staff?', 
          selectedStaff.every(staffId => participantIds.includes(staffId))
        );
      }
      
      // Trigger callbacks for real-time updates
      if (onMessageForwarded) {
        console.log('ðŸ“¡ Triggering onMessageForwarded callback for real-time refresh');
        await onMessageForwarded(conversation, result); // Await in case callback is async
      }
      
      // Prepare success message with list of people
      const forwardedNames = selectedStaffDetails.map(s => s.full_name || `${s.first_name} ${s.last_name}`);
      setForwardedToNames(forwardedNames);
      
      // Show success modal with names
      setShowSuccess(true);
      
      // Close main modal and reset after showing success
      setTimeout(() => {
        onHide();
        setSelectedStaff([]);
        setSearchTerm('');
        setAdditionalText('');
        setError(null);
        setForwardedToNames([]);
      }, 2500); // Give time to read the success message
      
      // Note: Pusher will handle real-time updates for all participants
      // The receiving conversation will get a 'new-message' event automatically
    } catch (err) {
      console.error('âŒ Error sharing message:', err);
      console.error('âŒ Error details:', {
        message: err.message,
        response: err.response?.data,
        status: err.response?.status,
        selectedStaff,
        hotelSlug,
        currentUserId
      });
      setError('Failed to share message. Please try again.');
    } finally {
      setSharing(false);
    }
  };

  const handleClose = () => {
    setSelectedStaff([]);
    setSearchTerm('');
    setAdditionalText('');
    setError(null);
    onHide();
  };

  // Filter staff by search term
  const filteredStaff = staffList.filter(staff =>
    `${staff.first_name || ''} ${staff.last_name || ''} ${staff.full_name || ''}`
      .toLowerCase()
      .includes(searchTerm.toLowerCase()) ||
    (staff.role || '').toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <>
      <Modal show={show} onHide={handleClose} centered size="lg">
        <Modal.Header closeButton>
          <Modal.Title>Forward Message</Modal.Title>
        </Modal.Header>

      <Modal.Body>
        {/* Message Preview */}
        <div className="share-message-modal__preview">
          <div className="share-message-modal__preview-header">
            <div className="d-flex align-items-center gap-2 mb-2">
              <i className="bi bi-arrow-right-circle text-primary"></i>
              <strong>Forwarded from {message.sender?.first_name || 'User'}</strong>
            </div>
          </div>
          <div className="share-message-modal__preview-content">
            {/* Show text message if present and not placeholder */}
            {message.message && message.message !== '[File shared]' && (
              <p className="mb-2">{message.message}</p>
            )}
            
            {/* Show image previews */}
            {message.attachments && message.attachments.length > 0 && (
              <div className="share-message-modal__attachments-preview mt-2">
                {message.attachments.map((att, index) => {
                  // Check if it's an image
                  const isImage = att.file_type === 'image' || 
                                  att.mime_type?.startsWith('image/') ||
                                  /\.(jpg|jpeg|png|gif|webp|bmp)$/i.test(att.file_name);
                  
                  if (isImage) {
                    return (
                      <div key={att.id || index} className="mb-2">
                        <img 
                          src={att.file_url} 
                          alt={att.file_name}
                          className="img-fluid rounded"
                          style={{ maxWidth: '100%', maxHeight: '200px', objectFit: 'contain' }}
                        />
                        <small className="text-muted d-block mt-1">
                          <i className="bi bi-image me-1"></i>
                          {att.file_name}
                        </small>
                      </div>
                    );
                  } else {
                    return (
                      <div key={att.id || index} className="mb-2">
                        <div className="d-flex align-items-center gap-2 p-2 bg-light rounded">
                          <i className="bi bi-file-earmark text-primary"></i>
                          <span className="text-truncate">{att.file_name}</span>
                        </div>
                      </div>
                    );
                  }
                })}
              </div>
            )}
          </div>
        </div>

        {/* Error Alert */}
        {error && (
          <Alert variant="danger" className="mt-3" onClose={() => setError(null)} dismissible>
            {error}
          </Alert>
        )}

        {/* Search Staff */}
        <Form.Group className="mt-3">
          <Form.Control
            type="text"
            placeholder="ðŸ” Search staff by name or role..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            disabled={loading}
          />
        </Form.Group>

        {/* Staff Selector */}
        <Form.Group className="mt-3">
          <Form.Label>Forward to:</Form.Label>
          {loading || loadingConversations ? (
            <div className="text-center py-3">
              <div className="spinner-border spinner-border-sm me-2" role="status">
                <span className="visually-hidden">Loading...</span>
              </div>
              {loadingConversations ? 'Loading conversations...' : 'Loading staff...'}
            </div>
          ) : staffList.length === 0 ? (
            <Alert variant="info">
              No other staff members available.
            </Alert>
          ) : (
            <>
              <ListGroup 
                ref={staffListRef}
                className="share-message-modal__staff-list" 
                style={{ maxHeight: '300px', overflowY: 'auto' }}
                onScroll={handleScroll}
              >
                {filteredStaff.map(staff => (
                  <ListGroup.Item
                    key={staff.id}
                    action
                    active={selectedStaff.includes(staff.id)}
                    onClick={() => toggleStaff(staff.id)}
                    className="d-flex align-items-center"
                  >
                    {/* Avatar */}
                    <div className="me-3">
                      {staff.profile_image_url ? (
                        <img 
                          src={staff.profile_image_url} 
                          alt={staff.full_name || `${staff.first_name} ${staff.last_name}`}
                          className="rounded-circle"
                          width="40"
                          height="40"
                          style={{ objectFit: 'cover' }}
                        />
                      ) : (
                        <div 
                          className="rounded-circle bg-secondary text-white d-flex align-items-center justify-content-center fw-bold"
                          style={{ width: '40px', height: '40px' }}
                        >
                          {(staff.first_name?.[0] || staff.full_name?.[0] || '?').toUpperCase()}
                        </div>
                      )}
                    </div>
                    
                    {/* Staff Info */}
                    <div className="flex-grow-1">
                      <div className="fw-semibold">
                        {staff.full_name || `${staff.first_name || ''} ${staff.last_name || ''}`.trim()}
                      </div>
                      {staff.role && (
                        <small className="text-muted">
                          {typeof staff.role === 'string' ? staff.role : staff.role.name || staff.role.slug || ''}
                        </small>
                      )}
                    </div>
                    
                    {/* Selected Indicator */}
                    {selectedStaff.includes(staff.id) && (
                      <i className="bi bi-check-circle-fill text-primary"></i>
                    )}
                  </ListGroup.Item>
                ))}
                
                {/* Loading More Indicator */}
                {loadingMore && (
                  <ListGroup.Item className="text-center py-3">
                    <div className="spinner-border spinner-border-sm text-primary me-2" role="status">
                      <span className="visually-hidden">Loading...</span>
                    </div>
                    <small className="text-muted">Loading more staff...</small>
                  </ListGroup.Item>
                )}
                
                {/* All Loaded Message */}
                {!hasMore && staffList.length > 0 && (
                  <ListGroup.Item className="text-center py-2">
                    <small className="text-muted">All staff members loaded</small>
                  </ListGroup.Item>
                )}
              </ListGroup>
              
              {/* Selected Count */}
              {selectedStaff.length > 0 && (
                <div className="mt-2">
                  <small className="text-primary fw-semibold">
                    {selectedStaff.length} staff member{selectedStaff.length > 1 ? 's' : ''} selected
                  </small>
                </div>
              )}
            </>
          )}
        </Form.Group>

        {/* Additional Message */}
        <Form.Group className="mt-3">
          <Form.Label>Add a message (optional):</Form.Label>
          <Form.Control
            as="textarea"
            rows={3}
            value={additionalText}
            onChange={(e) => setAdditionalText(e.target.value)}
            placeholder="Add your own message..."
            disabled={sharing}
          />
          <Form.Text className="text-muted">
            This will be added to the shared message.
          </Form.Text>
        </Form.Group>
      </Modal.Body>

      <Modal.Footer>
        <Button variant="secondary" onClick={handleClose} disabled={sharing}>
          Cancel
        </Button>
        <Button
          variant="primary"
          onClick={handleShare}
          disabled={selectedStaff.length === 0 || sharing || staffList.length === 0}
        >
          {sharing ? (
            <>
              <span className="spinner-border spinner-border-sm me-2" role="status">
                <span className="visually-hidden">Forwarding...</span>
              </span>
              Forwarding...
            </>
          ) : (
            <>
              <i className="bi bi-arrow-right-circle me-2"></i>
              Forward to {selectedStaff.length || '...'}
            </>
          )}
        </Button>
      </Modal.Footer>
      </Modal>

      {/* Success Modal with list of recipients */}
      <Modal show={showSuccess} onHide={() => setShowSuccess(false)} centered size="sm">
        <Modal.Body className="text-center py-4">
          <div className="mb-3">
            <i className="bi bi-check-circle-fill text-success" style={{ fontSize: '3rem' }}></i>
          </div>
          <h5 className="mb-3">Message Forwarded!</h5>
          <p className="text-muted mb-2 small">Forwarded to:</p>
          <div className="d-flex flex-column gap-2">
            {forwardedToNames.map((name, index) => (
              <div key={index} className="badge bg-primary bg-opacity-10 text-primary py-2">
                <i className="bi bi-person-check me-2"></i>
                {name}
              </div>
            ))}
          </div>
        </Modal.Body>
      </Modal>
    </>
  );
};

ShareMessageModal.propTypes = {
  show: PropTypes.bool.isRequired,
  onHide: PropTypes.func.isRequired,
  message: PropTypes.shape({
    id: PropTypes.number.isRequired,
    message: PropTypes.string,
    content: PropTypes.string,
    sender: PropTypes.shape({
      id: PropTypes.number,
      first_name: PropTypes.string,
      full_name: PropTypes.string,
    }),
    attachments: PropTypes.arrayOf(
      PropTypes.shape({
        id: PropTypes.number,
        file_name: PropTypes.string,
      })
    ),
  }).isRequired,
  hotelSlug: PropTypes.string.isRequired,
  currentUserId: PropTypes.number.isRequired,
  onMessageForwarded: PropTypes.func, // Optional callback for real-time refresh
  onOpenConversation: PropTypes.func, // Optional callback to open the target conversation
};

export default ShareMessageModal;
